// This is an animated JavaScript version of the PlasmaCloud
// example from Section 2.3 (Recursion) of the book
// "Introduction to Programming in Java" by Robert
// Sedgewick and Kevin Wayne.
// http://introcs.cs.princeton.edu/java/23recursion/PlasmaCloud.java.html
// It is amazingly fast on Java 8 because the Java bytecode
// generated by Nashorn JavaScript engine is JIT compiled.

// Changed for Bio7 (no AWT Window available!)

    w=1000; h=700;
    n = 250;
    ran = new Random();
    ip = new ColorProcessor(w,h);
    imp = null;
    c1 = ran.nextDouble();
    c2 = ran.nextDouble();
    c3 = ran.nextDouble();
    c4 = ran.nextDouble();
    IJ.resetEscape();
    t0 = System.currentTimeMillis();
    for (i=0; i<n; i++) {
        c1 += ran.nextGaussian()*0.003;
        c2 += ran.nextGaussian()*0.003;
        c3 += ran.nextGaussian()*0.003;
        c4 += ran.nextGaussian()*0.003;
        t1 = System.currentTimeMillis();
        update();
        time = System.currentTimeMillis() - t1;
        win = imp.getWindow();
        if (IJ.escapePressed() || win==null || (i>3&&time>300)) {
            IJ.beep();
            break;
        };
        IJ.showStatus((i+1)+"/"+n+" ("+time+"ms)");
        IJ.wait(25);
     }
     time = System.currentTimeMillis() - t0;
     fps = IJ.d2s(n/(time/1000),1);
     imp.setTitle("Plasma Clouds ("+fps+" fps)");
 
    function update() {
       // choose intial corner colors at random betwen 0 and 1
        ran = new Random(0);
        var stddev = 0.75; // controls color variation
        plasma(0.5, 0.5, 0.5, stddev, c1, c2, c3, c4);
        if (imp==null) {
            imp = new ImagePlus("Plasma Clouds", ip);
            imp.show();
        } else {
            imp.updateAndDraw();
            IJ.getInstance().toFront();
        }
   }

    function plasma(x,  y,  size, stddev, c1, c2, c3, c4) {
         "use strict"; // run this function in strict mode
         if (size<=0.001) return;
 
        // calculate new color of midpoint using random displacement
        var displacement = ran.nextGaussian()*stddev;
        var cM = (c1 + c2 + c3 + c4) / 4.0 + displacement;
 
        // draw a colored square
        var color = Color.getHSBColor(cM, 0.75, 0.8);
        ip.setColor(color);
        var w2 = Math.round(size*w*2);
        var h2 = Math.round(size*h*2);
        var x2 = Math.round((x-size)*w);
        var y2 = Math.round((y-size)*h);
        ip.fillRect(x2, y2, w2, h2);
 
        var cT = (c1 + c2) / 2.0;    // top
        var cB = (c3 + c4) / 2.0;    // bottom
        var cL = (c1 + c3) / 2.0;    // left
        var cR = (c2 + c4) / 2.0;    // right

        plasma(x - size/2, y - size/2, size/2, stddev/2, cL, cM, c3, cB);
        plasma(x + size/2, y - size/2, size/2, stddev/2, cM, cR, cB, c4);
        plasma(x - size/2, y + size/2, size/2, stddev/2, c1, cT, cL, cM);
        plasma(x + size/2, y + size/2, size/2, stddev/2, cT, c2, cM, cR);
    }
